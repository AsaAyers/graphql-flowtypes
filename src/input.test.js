// @flow
/* eslint-env jest */
import template from '@babel/template'
import { transform } from '.'
import traverse from '@babel/traverse'

export const parserConfig = {
  plugins: [
    'jsx',
    'flow',
    'doExpressions',
    'objectRestSpread',
    'decorators',
    'classProperties',
    'exportExtensions',
    'asyncGenerators',
    'functionBind',
    'functionSent',
    'dynamicImport'
  ]
}

const stripLocation = (ast) => {
  traverse(ast, {
    enter (path) {
      delete path.node.start
      delete path.node.end
      delete path.node.loc
    }
  })
  // I don't know why traverse doesn't visit the root node
  delete ast.start
  delete ast.end
  delete ast.loc
  return ast
}

const testMacro = ({ graphql, flow }) => async () => {
  // Copied from Github's schema
  const actual = transform(graphql)

  const babelAst = template.program(flow, parserConfig)({})
  const expected = stripLocation(babelAst)

  expect(actual).toEqual(expected)
}

test('will convert a simple `input` containing only primatives', testMacro({
  // Copied from Github's schema
  graphql: `
  # Autogenerated input type of AcceptTopicSuggestion
  input AcceptTopicSuggestionInput {
    # A unique identifier for the client performing the mutation.
    clientMutationId: String

    # The name of the suggested topic.
    name: String!

    # The Node ID of the repository.
    repositoryId: ID!
  }
  `,
  flow: `
  type AcceptTopicSuggestionInput = {|
    clientMutationId?: ?string,
    name: string,
    repositoryId: string,
  |}
  `
}))

test('will convert a simple `type`', testMacro({
  // Copied from Github's schema
  graphql: `
  # Autogenerated return type of AcceptTopicSuggestion
  type AcceptTopicSuggestionPayload {
    # A unique identifier for the client performing the mutation.
    clientMutationId: String

    # The accepted topic.
    topic: Topic!
  }
  `,
  flow: `
  type AcceptTopicSuggestionPayload = {|
    clientMutationId?: ?string,
    topic: Topic,
  |}
  `
}))
